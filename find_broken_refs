#!/usr/bin/env node

const { readFile, stat } = require('fs').promises;
const { dirname, join } = require('path');
const { getFiles, getRedirects } = require('./include');

const firstArg = process.argv[2];
const excludeOutdated = firstArg === '--exclude-outdated' || firstArg === '-x';
const checkRedirects = firstArg === '--check-redirects' || firstArg === '-c';
const paths = process.argv.slice(excludeOutdated || checkRedirects ? 3 : 2);

if (paths.length === 0)
    paths.push('.');

const broken = new Set();
const redirects = getRedirects();
let trailingSlashCount = 0;

async function findBrokenRefs(path) {
    const file = await readFile(path, 'utf8');

    if (excludeOutdated && path.endsWith('.md') && !path.endsWith('en.md') && file.match(/^outdated: true$/m) !== null)
        return;

    for (const match of file.matchAll(/\[.*?\]\((.+?)(?:#.+?)?(?: ".+?")?\)|^\[.*?\]: (.+?)(?:#.+?)?(?: ".+?")?$/gm)) {
        let ref = match[1] || match[2];

        if (ref.match(/^[a-z]+:\/\/|^mailto:|^#/) !== null)
            continue;

        const realRef = ref.startsWith('/')
            ? join(__dirname, '..', ref)
            : join(dirname(path), ref);

        try {
            await stat(realRef);
        } catch (e) {
            if (!checkRedirects ||
                !ref.startsWith('/wiki/') ||
                redirects[ref.replace('/wiki/', '').toLowerCase()] === undefined
            )
                broken.add(ref);
        }

        if (ref.endsWith('/'))
            ++trailingSlashCount;
    }
}

(async () => {
    for (const path of await getFiles(...paths))
        if (path.endsWith('.md'))
            await findBrokenRefs(path);

    for (const ref of broken)
        console.error(ref);

    console.log(`There are ${broken.size} unique broken references.`);
    console.log(`${trailingSlashCount} references have a trailing slash.`);
})();
