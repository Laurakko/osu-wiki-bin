#!/usr/bin/env node

const { readFile, stat } = require('fs').promises;
const { dirname, join } = require('path');
const { getFiles } = require('./include');

const firstArg = process.argv[2];
const excludeOutdated = firstArg === '--exclude-outdated' || firstArg === '-x';
const subDirectories = process.argv.slice(excludeOutdated ? 3 : 2);

if (subDirectories.length === 0)
    subDirectories.push('');

const broken = new Set();
let trailingSlashCount = 0;

async function findBrokenRefs(path) {
    const file = await readFile(path, 'utf8');

    if (excludeOutdated && path.endsWith('.md') && !path.endsWith('en.md') && file.match(/^outdated: true$/m) !== null)
        return;

    for (const match of file.matchAll(/\[.*?\]\((.+?)(?:#.+?)?(?: ".+?")?\)|^\[.*?\]: (.+?)(?:#.+?)?(?: ".+?")?$/gm)) {
        let ref = match[1] || match[2];

        if (ref.match(/^(?:https?:\/\/|mailto:|#)/) !== null)
            continue;

        const realRef = ref.startsWith('/')
            ? join(__dirname, '..', ref)
            : join(dirname(path), ref);

        try {
            await stat(realRef);
        } catch (e) {
            broken.add(ref);
        }

        if (ref.endsWith('/'))
            ++trailingSlashCount;
    }
}

(async () => {
    for (const subDirectory of subDirectories) {
        if (subDirectory.endsWith('.md'))
            await findBrokenRefs(subDirectory);
        else
            for (const path of await getFiles(join(__dirname, '..', subDirectory)))
                if (path.endsWith('.md'))
                    await findBrokenRefs(path);
    }

    for (const ref of broken)
        console.error(ref);

    console.log(`There are ${broken.size} unique broken references.`);
    console.log(`${trailingSlashCount} references have a trailing slash.`);
})();
